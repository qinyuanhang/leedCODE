///如果是搜索二叉树的话，就是下面这个
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        TreeNode res ;
        if(p.val > q.val){
            TreeNode temp = q;
            q = p;
            p = temp;
        }
        
        if(root.val >= p.val && root.val <= q.val){
            return root;
        }else if(root.val < p.val){
            res = lowestCommonAncestor(root.right, p, q);
        }else {
            res = lowestCommonAncestor(root.left, p, q);
        }
        
        return res;
    }
}

//////这个是使用所有的二叉树的方法，如果是bst的话，会简单一点
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
        if(root == null) return null;
        if(root.val == p.val || root.val == q.val) return root;
        boolean left = help(root.left, p, q);
        boolean right = help(root.right, q, p);
        TreeNode res;
        if(left && right){
            return root;
        }else if(left && !right){
            res = lowestCommonAncestor(root.left, p, q);
        }else{
            res = lowestCommonAncestor(root.right, p, q);
        }
        
        return res;
    }
    
    
    private boolean help(TreeNode root, TreeNode p, TreeNode q){
        if(root == null) return false;
        
        if(root.val == p.val || root.val == q.val) return true;
        
        return  (help(root.left, p, q) || help(root.right, p, q));
    }
}

这道题的本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。
那么我们对于这类求极值的问题首先考虑动态规划Dynamic Programming来解，我们维护一个一位数组dp，
其中dp[i]表示到i位置时不相邻数能形成的最大和，经过分析，
我们可以得到递推公式dp[i] = max(num[i] + dp[i - 2], dp[i - 1]),
由此看出我们需要初始化dp[0]和dp[1]，其中dp[0]即为num[0]，dp[1]此时应该为max(num[0], num[1])，代码如下：


public class Solution {
    public int rob(int[] num) {
        if(num.length == 0) return 0;
         if(num.length == 1) return num[0];
          if(num.length == 2) return Math.max(num[0],num[1]);
        
        int [] dp = new int [num.length];
        dp[0] = num[0];
        dp[1] = Math.max(num[0],num[1]);
        
        for(int i = 2; i < num.length; i ++){
            dp[i] = Math.max(dp[i-1],num[i] + dp[i - 2]); 
        }
        
        return dp[dp.length - 1];
    }
}

这个是O（n）和空间也是O（n）的，
下面这个是O（n）但是空间是O（1）；


public class Solution {
    public int rob(int[] num) {
        if(num.length == 0) return 0;
         if(num.length == 1) return num[0];
          if(num.length == 2) return Math.max(num[0],num[1]);
        
       int even,odd;
       
        even = num[0];
        odd = Math.max(num[0],num[1]);
        
        for(int i = 2; i < num.length; i ++){
            if(i % 2 == 0){
                even = Math.max(odd,even + num[i]);
            }else{
                odd = Math.max(odd + num[i] , even);
            }
        }
        
        return Math.max(even,odd);
    }
}

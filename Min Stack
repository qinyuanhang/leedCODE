/**
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
*/

/**要求要注意的是所有操作都得是O（1）的时间，这时候我们就可以用两个集合类
，一个直接进行加减，另一个就可以用来存最小值**/


/**
那么问题来了！！我刚开始想不通的是，要是我一开始放1，后面都放比1大得数字，存最小值的集合里面就只有1，这时要是进行pop
操作，那最小值集合不就空了吗？
*/

class MinStack {
    
    ArrayList<Integer> list = new ArrayList<Integer>();
    ArrayList<Integer>  min = new ArrayList<Integer>();
    
    
    public void push(int x) {
       list.add(x)；
       /**
       这里解决问题，只要list不空，min里面就绝对不会空，因为list和min的第一个是相同的，
       */
       if(min.isEmpty() || min.get(min.size()-1)>=list.get(list.size()-1)){
           min.add(x);
       }
    }
    public void pop() ；
        if(list.isEmpty())  
        {  
            return;  
        }  
        int elem = list.remove(list.size()-1);  
        /**
        这个pop操作是要比较list pop出来的值和min的第一个相同，两个才pop出来，否则min将不会变，这就保证了
        当list不是pop最后一个数值的话，min永远不会空，而且，当前list里面的最小值一直都在min的第一个，
        只有list要pop当前最小值的时候，min才会把当前最小值pop出来，而min的第二个，也就是list pop之后，所剩下的
        最小值，变成了min得第一个。min的第一个永远是list得当前最小时，而且，list和min的最后一个数字是同时出现，
        同时消失。 聪明！！！
        */
        if(elem == min.get(min.size()-1))  
        {  
            min.remove(min.size()-1);  
        }  
    }
    public int top() {
        if(list.isEmpty())
        return 0;
        return list.get(list.size()-1);
    }
    public int getMin() {
        if(min.isEmpty())
        return 0;
        return min.get(min.size()-1);
    }
}

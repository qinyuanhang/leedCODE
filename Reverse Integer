/**
Reverse digits of an integer.

Example1: x = 123, return 321
Example2: x = -123, return -321

click to show spoilers.

Have you thought about this?
Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!

If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.

Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?

For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

Update (2014-11-10):
Test cases had been added to test the overflow behavior.


*/

public class Solution {
    public int reverse(int x) {
        int ret = 0;  
   while (x != 0) {  
      // 考虑溢出之后这道题就没什么可以改进的了，主要就是这个判断溢出有点tricky
      /**
      真正的Int的范围是在
      -2147483648～2147483647 
      为什么这里用 214748364（少了最后一位，也就是INT_MAX%10）？？？？？？？
      
      用文字解释比较难，，我都不确定自己以后能看懂。。。。
      
      是这样的，翻转前的数字，一定是在这个范围内的，所以，翻转后的数字，最大最大的最后一位只能是1或者2.
      （十个数字）xxxxxxxxx1或者xxxxxxxxx2
            我们只要比较前面9位（xxxxxxxxx）是否大于214748364就可以了。
            这道题要经常看看。很启发。
      */
      if (Math.abs(ret) > 214748364) {     
         return 0;  
      }  
      ret = ret * 10 + x % 10;  //注意求余和除法的区别
      x /= 10;  
   }  
   return ret;  
    }
}
